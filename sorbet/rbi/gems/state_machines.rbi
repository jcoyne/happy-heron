# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/state_machines/all/state_machines.rbi
#
# state_machines-0.5.0

module StateMachines
end
class Hash
  def assert_exclusive_keys(*exclusive_keys); end
end
class StateMachines::Error < StandardError
  def initialize(object, message = nil); end
  def object; end
end
class StateMachines::IntegrationNotFound < StateMachines::Error
  def error_message; end
  def initialize(name); end
  def no_integrations; end
  def valid_integrations; end
  def valid_integrations_name; end
end
class StateMachines::IntegrationError < StandardError
end
class StateMachines::InvalidEvent < StateMachines::Error
  def event; end
  def initialize(object, event_name); end
end
class StateMachines::InvalidTransition < StateMachines::Error
  def event; end
  def from; end
  def from_name; end
  def initialize(object, machine, event); end
  def machine; end
  def qualified_event; end
  def qualified_from_name; end
end
class StateMachines::InvalidParallelTransition < StateMachines::Error
  def events; end
  def initialize(object, events); end
end
class StateMachines::InvalidContext < StateMachines::Error
end
module StateMachines::ClassMethods
  def self.extended(base); end
  def state_machines; end
end
module StateMachines::InstanceMethods
  def fire_events!(*events); end
  def fire_events(*events); end
  def initialize_state_machines(options = nil, &block); end
end
module StateMachines::Integrations
  def self.add(integration); end
  def self.find_by_name(name); end
  def self.integrations; end
  def self.list; end
  def self.match(klass); end
  def self.match_ancestors(ancestors); end
  def self.register(name_or_module); end
  def self.reset; end
end
module StateMachines::Integrations::Base
  def self.included(base); end
end
module StateMachines::Integrations::Base::ClassMethods
  def defaults; end
  def integration_name; end
  def matches?(klass); end
  def matches_ancestors?(ancestors); end
  def matching_ancestors; end
end
module StateMachines::EvalHelpers
  def evaluate_method(object, method, *args, &block); end
end
class StateMachines::Matcher
  def filter(values); end
  def initialize(values = nil); end
  def values; end
end
class StateMachines::AllMatcher < StateMachines::Matcher
  def -(blacklist); end
  def description; end
  def filter(values); end
  def matches?(value, context = nil); end
  def self.allocate; end
  def self.new(*arg0); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
class StateMachines::WhitelistMatcher < StateMachines::Matcher
  def description; end
  def matches?(value, context = nil); end
end
class StateMachines::BlacklistMatcher < StateMachines::Matcher
  def description; end
  def filter(values); end
  def matches?(value, context = nil); end
end
class StateMachines::LoopbackMatcher < StateMachines::Matcher
  def description; end
  def matches?(value, context); end
  def self.allocate; end
  def self.new(*arg0); end
  extend Singleton::SingletonClassMethods
  include Singleton
end
module StateMachines::MatcherHelpers
  def all; end
  def any; end
  def same; end
end
class StateMachines::Transition
  def ==(other); end
  def action; end
  def after; end
  def args; end
  def args=(arg0); end
  def attribute; end
  def attributes; end
  def before(complete = nil, index = nil, &block); end
  def context; end
  def event; end
  def from; end
  def from_name; end
  def human_event; end
  def human_from_name; end
  def human_to_name; end
  def initialize(object, machine, event, from_name, to_name, read_state = nil); end
  def inspect; end
  def loopback?; end
  def machine; end
  def object; end
  def pausable; end
  def pause; end
  def perform(*args); end
  def persist; end
  def qualified_event; end
  def qualified_from_name; end
  def qualified_to_name; end
  def reset; end
  def result; end
  def resume; end
  def rollback; end
  def run_callbacks(options = nil, &block); end
  def self.pause_supported?; end
  def to; end
  def to_name; end
  def transient=(arg0); end
  def transient?; end
  def within_transaction; end
end
class StateMachines::TransitionCollection < Array
  def actions; end
  def catch_exceptions; end
  def initialize(transitions = nil, options = nil); end
  def object; end
  def perform(&block); end
  def persist; end
  def reset; end
  def results; end
  def rollback; end
  def run_actions; end
  def run_callbacks(index = nil, &block); end
  def skip_actions; end
  def skip_after; end
  def success?; end
  def use_event_attributes?; end
  def use_transactions; end
  def valid?; end
  def within_transaction; end
end
class StateMachines::AttributeTransitionCollection < StateMachines::TransitionCollection
  def initialize(transitions = nil, options = nil); end
  def persist; end
  def reset; end
  def rollback; end
  def run_callbacks(index = nil); end
end
class StateMachines::Branch
  def build_matcher(options, whitelist_option, blacklist_option); end
  def draw(graph, event, valid_states); end
  def event_requirement; end
  def if_condition; end
  def initialize(options = nil); end
  def known_states; end
  def match(object, query = nil); end
  def match_event(query); end
  def match_query(query); end
  def match_states(query); end
  def matches?(object, query = nil); end
  def matches_conditions?(object, query); end
  def matches_requirement?(query, option, requirement); end
  def state_requirements; end
  def unless_condition; end
  include StateMachines::EvalHelpers
end
class StateMachines::HelperModule < Module
  def initialize(machine, kind); end
  def to_s; end
end
class StateMachines::State
  def add_predicate; end
  def cache; end
  def cache=(arg0); end
  def cache_value?; end
  def call(object, method, *args, &block); end
  def context(&block); end
  def context_methods; end
  def context_name_for(method); end
  def description(options = nil); end
  def draw(graph, options = nil); end
  def final?; end
  def human_name(klass = nil); end
  def human_name=(arg0); end
  def initial; end
  def initial=(arg0); end
  def initial?; end
  def initialize(machine, name, options = nil); end
  def initialize_copy(orig); end
  def inspect; end
  def machine; end
  def machine=(machine); end
  def matcher; end
  def matcher=(arg0); end
  def matches?(other_value); end
  def name; end
  def qualified_name; end
  def value(eval = nil); end
  def value=(arg0); end
end
class StateMachines::Callback
  def bound_method(block); end
  def branch; end
  def call(object, context = nil, *args, &block); end
  def initialize(type, *args, &block); end
  def known_states; end
  def run_methods(object, context = nil, index = nil, *args, &block); end
  def self.bind_to_object; end
  def self.bind_to_object=(arg0); end
  def self.terminator; end
  def self.terminator=(arg0); end
  def terminator; end
  def type; end
  def type=(arg0); end
  include StateMachines::EvalHelpers
end
class StateMachines::NodeCollection
  def <<(node); end
  def [](key, index_name = nil); end
  def add_to_index(name, key, node); end
  def at(index); end
  def concat(nodes); end
  def context(nodes, &block); end
  def each; end
  def eval_context(context, node); end
  def fetch(key, index_name = nil); end
  def index(name); end
  def initialize(machine, options = nil); end
  def initialize_copy(orig); end
  def keys(index_name = nil); end
  def length; end
  def machine; end
  def machine=(new_machine); end
  def remove_from_index(name, key); end
  def to_sym?(value); end
  def update(node); end
  def update_index(name, node); end
  def value(node, attribute); end
  include Enumerable
end
class StateMachines::StateContext < Module
  def initialize(state); end
  def machine; end
  def method_missing(*args, &block); end
  def state; end
  def transition(options); end
  include StateMachines::EvalHelpers
end
class StateMachines::StateCollection < StateMachines::NodeCollection
  def by_priority; end
  def initialize(machine); end
  def match!(object); end
  def match(object); end
  def matches?(object, name); end
  def value(node, attribute); end
end
class StateMachines::Event
  def add_actions; end
  def branches; end
  def can_fire?(object, requirements = nil); end
  def context(&block); end
  def draw(graph, options = nil); end
  def fire(object, *args); end
  def human_name(klass = nil); end
  def human_name=(arg0); end
  def initialize(machine, name, options = nil); end
  def initialize_copy(orig); end
  def inspect; end
  def known_states; end
  def machine; end
  def machine=(arg0); end
  def name; end
  def on_failure(object); end
  def qualified_name; end
  def reset; end
  def transition(options); end
  def transition_for(object, requirements = nil); end
  include StateMachines::MatcherHelpers
end
class StateMachines::EventCollection < StateMachines::NodeCollection
  def attribute_transition_for(object, invalidate = nil); end
  def initialize(machine); end
  def match(requirements); end
  def transitions_for(object, requirements = nil); end
  def valid_for(object, requirements = nil); end
end
class StateMachines::Path < Array
  def can_walk_to?(transition); end
  def complete?; end
  def events; end
  def from_name; end
  def from_states; end
  def initialize(object, machine, options = nil); end
  def initialize_copy(orig); end
  def machine; end
  def object; end
  def recently_walked?(transition); end
  def times_walked_to(state); end
  def to_name; end
  def to_states; end
  def transitions; end
  def walk; end
end
class StateMachines::PathCollection < Array
  def events; end
  def from_name; end
  def from_states; end
  def initial_paths; end
  def initialize(object, machine, options = nil); end
  def machine; end
  def object; end
  def to_name; end
  def to_states; end
  def walk(path); end
end
class StateMachines::Machine
  def action; end
  def action_hook; end
  def action_hook?(self_only = nil); end
  def add_callback(type, options, &block); end
  def add_events(new_events); end
  def add_sibling_machine_configs; end
  def add_states(new_states); end
  def after_failure(*args, &block); end
  def after_initialize; end
  def after_transition(*args, &block); end
  def around_transition(*args, &block); end
  def attribute(name = nil); end
  def before_transition(*args, &block); end
  def callbacks; end
  def create_with_scope(name); end
  def create_without_scope(name); end
  def define_action_helpers; end
  def define_action_helpers?; end
  def define_action_hook; end
  def define_event_helpers; end
  def define_helper(scope, method, *args, &block); end
  def define_helpers; end
  def define_name_helpers; end
  def define_path_helpers; end
  def define_scopes(custom_plural = nil); end
  def define_state_accessor; end
  def define_state_initializer; end
  def define_state_predicate; end
  def draw(graph_options = nil); end
  def dynamic_initial_state?; end
  def errors_for(_object); end
  def event(*names, &block); end
  def events; end
  def generate_message(name, values = nil); end
  def initial_state(object); end
  def initial_state=(new_initial_state); end
  def initialize(owner_class, *args, &block); end
  def initialize_copy(orig); end
  def initialize_state(object, options = nil); end
  def initialize_state?(object); end
  def invalidate(_object, _attribute, _message, _values = nil); end
  def name; end
  def namespace; end
  def on(*names, &block); end
  def other_states(*names, &block); end
  def owner_class; end
  def owner_class=(klass); end
  def owner_class_ancestor_has_method?(scope, method); end
  def owner_class_attribute_default; end
  def owner_class_attribute_default_matches?(state); end
  def owner_class_has_method?(scope, method); end
  def paths_for(object, requirements = nil); end
  def pluralize(word); end
  def read(object, attribute, ivar = nil); end
  def reset(_object); end
  def run_scope(scope, machine, klass, states); end
  def self.default_messages; end
  def self.default_messages=(arg0); end
  def self.draw(class_names, options = nil); end
  def self.find_or_create(owner_class, *args, &block); end
  def self.ignore_method_conflicts; end
  def self.ignore_method_conflicts=(arg0); end
  def sibling_machines; end
  def state(*names, &block); end
  def states; end
  def transaction(object); end
  def transition(options); end
  def use_transactions; end
  def within_transaction(object); end
  def write(object, attribute, value, ivar = nil); end
  include StateMachines::EvalHelpers
  include StateMachines::MatcherHelpers
end
class StateMachines::MachineCollection < Hash
  def fire_events(object, *events); end
  def initialize_states(object, options = nil, attributes = nil); end
  def resolve_use_transactions; end
  def transitions(object, action, options = nil); end
end
module StateMachines::MacroMethods
  def state_machine(*args, &block); end
end
class Class < Module
  include StateMachines::MacroMethods
end
