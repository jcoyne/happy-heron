# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: strict
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/serverengine/all/serverengine.rbi
#
# serverengine-2.0.7

module ServerEngine
  def self.create(server_module, worker_module, load_config_proc = nil, &block); end
  def self.ruby_bin_path; end
  def self.windows?; end
  extend ServerEngine::ClassMethods
end
module ServerEngine::ClassMethods
  def dump_uncaught_error(e); end
  def format_join_status(code); end
  def format_signal_name(n); end
end
module ServerEngine::Signals
end
module ServerEngine::CommandSender
end
module ServerEngine::CommandSender::Signal
  def _detach; end
  def _dump; end
  def _reload; end
  def _restart(graceful); end
  def _send_signal(sig); end
  def _stop(graceful); end
end
module ServerEngine::CommandSender::Pipe
  def _detach; end
  def _dump; end
  def _reload; end
  def _restart(graceful); end
  def _send_command(cmd); end
  def _stop(graceful); end
end
class Logger::LogDevice
  def reopen!; end
end
class ServerEngine::DaemonLogger < Logger
  def add(severity, message = nil, progname = nil, &block); end
  def close; end
  def initialize(logdev, config = nil); end
  def level=(expr); end
  def logdev=(logdev); end
  def reopen!; end
  def reopen; end
  def trace?; end
  include ServerEngine::DaemonLogger::Severity
end
module ServerEngine::DaemonLogger::Severity
  include Logger::Severity
end
module ServerEngine::ConfigLoader
  def config; end
  def create_logger; end
  def initialize(load_config_proc = nil, &block); end
  def logdev_from_config(config); end
  def logger; end
  def logger=(arg0); end
  def reload_config; end
end
module ServerEngine::Privilege
  def self.change(user, group); end
  def self.get_etc_group(group); end
  def self.get_etc_passwd(user); end
end
class ServerEngine::BlockingFlag
  def initialize; end
  def reset!; end
  def set!; end
  def set?; end
  def wait(timeout = nil); end
  def wait_for_reset(timeout = nil); end
  def wait_for_set(timeout = nil); end
end
class ServerEngine::ProcessManager
  def auto_heartbeat; end
  def auto_tick; end
  def auto_tick_interval; end
  def cloexec_mode; end
  def cloexec_mode=(arg0); end
  def close; end
  def command_sender; end
  def command_sender=(arg0); end
  def command_sender_pipe; end
  def configure(config, opts = nil); end
  def enable_heartbeat; end
  def fork(&block); end
  def graceful_kill_interval; end
  def graceful_kill_interval=(v); end
  def graceful_kill_interval_increment; end
  def graceful_kill_interval_increment=(v); end
  def graceful_kill_signal; end
  def graceful_kill_timeout; end
  def graceful_kill_timeout=(v); end
  def heartbeat_interval; end
  def heartbeat_interval=(v); end
  def heartbeat_timeout; end
  def heartbeat_timeout=(v); end
  def immediate_kill_interval; end
  def immediate_kill_interval=(v); end
  def immediate_kill_interval_increment; end
  def immediate_kill_interval_increment=(v); end
  def immediate_kill_signal; end
  def immediate_kill_timeout; end
  def immediate_kill_timeout=(v); end
  def initialize(config = nil); end
  def logger; end
  def logger=(arg0); end
  def monitor_options; end
  def new_pipe_pair; end
  def spawn(*args); end
  def tick(blocking_timeout = nil); end
end
class ServerEngine::ProcessManager::AlreadyClosedError < EOFError
end
class ServerEngine::ProcessManager::Monitor
  def heartbeat_delay; end
  def initialize(pid, opts = nil); end
  def join; end
  def last_heartbeat_time; end
  def last_heartbeat_time=(arg0); end
  def pid; end
  def send_signal(sig); end
  def start_graceful_stop!; end
  def start_immediate_stop!; end
  def tick(now = nil); end
  def try_join; end
end
class ServerEngine::ProcessManager::TickThread < Thread
  def initialize(auto_tick_interval, &tick); end
  def main; end
end
class ServerEngine::ProcessManager::Target
  def close; end
  def heartbeat!; end
  def initialize(pipe); end
  def pipe; end
end
class ServerEngine::ProcessManager::HeartbeatThread < Thread
  def initialize(heartbeat_interval, target, error_proc); end
  def main; end
end
class ServerEngine::SignalThread < Thread
  def enqueue(sig); end
  def handlers; end
  def initialize(&block); end
  def main; end
  def signal_handler_main(sig); end
  def stop; end
  def trap(sig, command = nil, &block); end
end
class ServerEngine::Worker
  def after_start; end
  def before_fork; end
  def config; end
  def dump; end
  def initialize(server, worker_id); end
  def install_signal_handlers; end
  def logger; end
  def logger=(arg0); end
  def main; end
  def reload; end
  def run; end
  def server; end
  def spawn(process_manager); end
  def stop; end
  def worker_id; end
end
class ServerEngine::Server
  def after_run; end
  def after_start; end
  def before_run; end
  def create_worker(wid); end
  def dump; end
  def initialize(worker_module, load_config_proc = nil, &block); end
  def install_signal_handlers; end
  def main; end
  def reload; end
  def restart(stop_graceful); end
  def start_io_logging_thread(io); end
  def stop(stop_graceful); end
  def try_get_io_from_logger(logger); end
  include ServerEngine::ConfigLoader
end
module ServerEngine::Server::WorkerInitializer
  def initialize; end
end
class ServerEngine::EmbeddedServer < ServerEngine::Server
  def reload; end
  def restart(stop_graceful); end
  def run; end
  def stop(stop_graceful); end
end
class ServerEngine::MultiWorkerServer < ServerEngine::Server
  def delayed_start_worker(wid); end
  def initialize(worker_module, load_config_proc = nil, &block); end
  def join_workers; end
  def keepalive_workers; end
  def reload; end
  def reload_config; end
  def restart(stop_graceful); end
  def run; end
  def scale_workers(n); end
  def stop(stop_graceful); end
  def wait_tick; end
end
class ServerEngine::MultiProcessServer < ServerEngine::MultiWorkerServer
  def initialize(worker_module, load_config_proc = nil, &block); end
  def logger=(logger); end
  def reload_config; end
  def run; end
  def start_worker(wid); end
  def wait_tick; end
end
class ServerEngine::MultiProcessServer::WorkerMonitor
  def alive?; end
  def exitstatus; end
  def initialize(worker, wid, pmon, reload_signal = nil, unrecoverable_exit_codes: nil); end
  def join; end
  def recoverable?; end
  def send_reload; end
  def send_stop(stop_graceful); end
end
class ServerEngine::MultiThreadServer < ServerEngine::MultiWorkerServer
  def start_worker(wid); end
end
class ServerEngine::MultiThreadServer::WorkerMonitor
  def alive?; end
  def initialize(worker, thread); end
  def join; end
  def recoverable?; end
  def send_reload; end
  def send_stop(stop_graceful); end
end
class ServerEngine::MultiSpawnServer < ServerEngine::MultiWorkerServer
  def initialize(worker_module, load_config_proc = nil, &block); end
  def logger=(logger); end
  def reload_config; end
  def run; end
  def start_worker(wid); end
  def stop(stop_graceful); end
  def wait_tick; end
end
class ServerEngine::Supervisor
  def create_server(logger); end
  def detach(stop_graceful); end
  def dump; end
  def initialize(server_module, worker_module, load_config_proc = nil, &block); end
  def install_signal_handlers; end
  def logger=(logger); end
  def main; end
  def reboot_server; end
  def reload; end
  def reload_config; end
  def restart(stop_graceful); end
  def self.create_server_proc(server_module, worker_module, config); end
  def send_signal(sig); end
  def server; end
  def start_server; end
  def stop(stop_graceful); end
  def try_join; end
  include ServerEngine::ConfigLoader
end
module ServerEngine::Supervisor::ServerInitializer
  def initialize; end
end
class ServerEngine::Daemon
  def create_server(logger); end
  def daemonize_with_double_fork(inpipe); end
  def daemonize_with_spawn(inpipe); end
  def detach; end
  def dump; end
  def initialize(server_module, worker_module, load_config_proc = nil, &block); end
  def main; end
  def reload; end
  def restart(graceful); end
  def run; end
  def self.run_server(server_module, worker_module, load_config_proc = nil, &block); end
  def server; end
  def server_main; end
  def stop(graceful); end
  def write_pid_file; end
  include ServerEngine::ConfigLoader
end
module ServerEngine::SocketManagerUnix
end
module ServerEngine::SocketManagerUnix::ClientModule
  def connect_peer(path); end
  def recv(family, proto, peer, sent); end
  def recv_tcp(family, peer, sent); end
  def recv_udp(family, peer, sent); end
end
module ServerEngine::SocketManagerUnix::ServerModule
  def listen_tcp_new(bind_ip, port); end
  def listen_udp_new(bind_ip, port); end
  def send_socket(peer, pid, method, bind, port); end
  def start_server(path); end
  def stop_server; end
end
module ServerEngine::SocketManager
  def self.recv_peer(peer); end
  def self.send_peer(peer, obj); end
end
class ServerEngine::SocketManager::Client
  def initialize(path); end
  def listen(proto, bind, port); end
  def listen_tcp(bind, port); end
  def listen_udp(bind, port); end
  include ServerEngine::SocketManagerUnix::ClientModule
end
class ServerEngine::SocketManager::Server
  def close; end
  def initialize(path); end
  def listen(proto, bind, port); end
  def listen_tcp(bind, port); end
  def listen_udp(bind, port); end
  def new_client; end
  def path; end
  def process_peer(peer); end
  def resolve_bind_key(bind, port); end
  def self.generate_path; end
  def self.open(path); end
  include ServerEngine::SocketManagerUnix::ServerModule
end
