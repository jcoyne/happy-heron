# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/openapi3_parser/all/openapi3_parser.rbi
#
# openapi3_parser-0.9.0

module Openapi3Parser
  def self.load(input); end
  def self.load_file(path); end
  def self.load_url(url); end
end
module Openapi3Parser::ArraySentence
end
class Openapi3Parser::CautiousDig
  def array_like(item, segment); end
  def call(collection, *segments); end
  def hash_like(item, segment); end
  def self.call(*args); end
  def self.new(*arg0); end
end
class Openapi3Parser::Document
  def [](*args, &block); end
  def add_warning(text); end
  def build; end
  def build_in_progress; end
  def built; end
  def components(*args, &block); end
  def determine_openapi_version(version); end
  def each(*args, &block); end
  def errors; end
  def extension(*args, &block); end
  def external_docs(*args, &block); end
  def factory; end
  def info(*args, &block); end
  def initialize(source_input); end
  def inspect; end
  def keys(*args, &block); end
  def look_up_pointer(pointer, relative_pointer, subject); end
  def node_at(pointer, relative_to = nil); end
  def openapi(*args, &block); end
  def openapi_version; end
  def paths(*args, &block); end
  def reference_factories; end
  def reference_registry; end
  def reference_sources; end
  def resolved_input_at(pointer, relative_to = nil); end
  def root; end
  def root_source; end
  def security(*args, &block); end
  def servers(*args, &block); end
  def source_for_source_input(source_input); end
  def sources; end
  def tags(*args, &block); end
  def valid?(*args, &block); end
  def warnings; end
  extend Forwardable
  include Enumerable
end
class Openapi3Parser::Document::ReferenceRegistry
  def build_factory(unbuilt_factory, source_location, reference_factory_context); end
  def factories; end
  def factories_by_type; end
  def factory(object_type, source_location); end
  def freeze; end
  def initialize; end
  def register(unbuilt_factory, source_location, reference_factory_context); end
  def register_factory(object_type, factory); end
  def register_source(source); end
  def sources; end
end
class Openapi3Parser::Error < RuntimeError
end
class Openapi3Parser::Error::InaccessibleInput < Openapi3Parser::Error
end
class Openapi3Parser::Error::UnparsableInput < Openapi3Parser::Error
end
class Openapi3Parser::Error::ImmutableObject < Openapi3Parser::Error
end
class Openapi3Parser::Error::InvalidType < Openapi3Parser::Error
end
class Openapi3Parser::Error::InvalidData < Openapi3Parser::Error
end
class Openapi3Parser::Error::MissingFields < Openapi3Parser::Error
end
class Openapi3Parser::Error::UnexpectedFields < Openapi3Parser::Error
end
class Openapi3Parser::Error::NotCallable < Openapi3Parser::Error
end
class Openapi3Parser::Error::InRecursiveStructure < Openapi3Parser::Error
end
class Openapi3Parser::Error::UnvalidatableType < Openapi3Parser::Error
end
module Openapi3Parser::Markdown
  def self.to_html(text); end
end
module Openapi3Parser::Node
end
class Openapi3Parser::Node::Array
  def ==(other); end
  def [](index); end
  def each(&block); end
  def empty?(*args, &block); end
  def initialize(data, context); end
  def inspect; end
  def length(*args, &block); end
  def node_at(pointer_like); end
  def node_context; end
  def node_data; end
  def size(*args, &block); end
  extend Forwardable
  include Enumerable
end
class Openapi3Parser::Node::Map
  def ==(other); end
  def [](value); end
  def each(&block); end
  def empty?(*args, &block); end
  def extension(value); end
  def initialize(data, context); end
  def inspect; end
  def keys(*args, &block); end
  def length(*args, &block); end
  def node_at(pointer_like); end
  def node_context; end
  def node_data; end
  def size(*args, &block); end
  def values; end
  extend Forwardable
  include Enumerable
end
class Openapi3Parser::Node::Callback < Openapi3Parser::Node::Map
end
class Openapi3Parser::Node::Object
  def ==(other); end
  def [](value); end
  def each(&block); end
  def empty?(*args, &block); end
  def extension(value); end
  def initialize(data, context); end
  def inspect; end
  def keys(*args, &block); end
  def node_at(pointer_like); end
  def node_context; end
  def node_data; end
  def render_markdown(value); end
  def values; end
  extend Forwardable
  include Enumerable
end
class Openapi3Parser::Node::Components < Openapi3Parser::Node::Object
  def callbacks; end
  def examples; end
  def headers; end
  def links; end
  def parameters; end
  def request_bodies; end
  def responses; end
  def schemas; end
  def security_schemes; end
end
class Openapi3Parser::Node::Contact < Openapi3Parser::Node::Object
  def email; end
  def name; end
  def url; end
end
class Openapi3Parser::Node::Context
  def ==(other); end
  def document; end
  def document_location; end
  def initialize(input, document_location:, source_location:); end
  def input; end
  def inspect; end
  def location_summary; end
  def node; end
  def parent_node; end
  def relative_node(pointer); end
  def resolved_input; end
  def same_data_and_source?(other); end
  def self.next_field(parent_context, field, factory_context); end
  def self.resolved_reference(current_context, reference_factory_context); end
  def self.root(factory_context); end
  def source; end
  def source_location; end
  def to_s; end
end
class Openapi3Parser::Node::Discriminator < Openapi3Parser::Node::Object
  def mapping; end
  def property_name; end
end
class Openapi3Parser::Node::Encoding < Openapi3Parser::Node::Object
  def allow_reserved?; end
  def content_type; end
  def explode?; end
  def headers; end
  def style; end
end
class Openapi3Parser::Node::Example < Openapi3Parser::Node::Object
  def description; end
  def description_html; end
  def external_value; end
  def summary; end
  def value; end
end
class Openapi3Parser::Node::ExternalDocumentation < Openapi3Parser::Node::Object
  def description; end
  def description_html; end
  def url; end
end
module Openapi3Parser::Node::ParameterLike
  def allow_empty_value?; end
  def allow_reserved?; end
  def content; end
  def deprecated?; end
  def description; end
  def description_html; end
  def example; end
  def examples; end
  def explode?; end
  def required?; end
  def schema; end
  def style; end
end
class Openapi3Parser::Node::Header < Openapi3Parser::Node::Object
  include Openapi3Parser::Node::ParameterLike
end
class Openapi3Parser::Node::Info < Openapi3Parser::Node::Object
  def contact; end
  def description; end
  def description_html; end
  def license; end
  def terms_of_service; end
  def title; end
  def version; end
end
class Openapi3Parser::Node::License < Openapi3Parser::Node::Object
  def name; end
  def url; end
end
class Openapi3Parser::Node::Link < Openapi3Parser::Node::Object
  def description; end
  def description_html; end
  def operation_id; end
  def operation_ref; end
  def parameters; end
  def request_body; end
  def server; end
end
class Openapi3Parser::Node::MediaType < Openapi3Parser::Node::Object
  def encoding; end
  def example; end
  def examples; end
  def schema; end
end
class Openapi3Parser::Node::OauthFlow < Openapi3Parser::Node::Object
  def authorization_url; end
  def refresh_url; end
  def scopes; end
  def token_url; end
end
class Openapi3Parser::Node::OauthFlows < Openapi3Parser::Node::Object
  def authorization_code; end
  def client_credentials; end
  def implicit; end
  def password; end
end
class Openapi3Parser::Node::Openapi < Openapi3Parser::Node::Object
  def components; end
  def external_docs; end
  def info; end
  def openapi; end
  def paths; end
  def security; end
  def servers; end
  def tags; end
end
class Openapi3Parser::Node::Operation < Openapi3Parser::Node::Object
  def alternative_servers?; end
  def callbacks; end
  def deprecated?; end
  def description; end
  def description_html; end
  def external_docs; end
  def operation_id; end
  def parameters; end
  def request_body; end
  def responses; end
  def security; end
  def servers; end
  def summary; end
  def tags; end
end
class Openapi3Parser::Node::Parameter < Openapi3Parser::Node::Object
  def in; end
  def name; end
  include Openapi3Parser::Node::ParameterLike
end
class Openapi3Parser::Node::PathItem < Openapi3Parser::Node::Object
  def alternative_servers?; end
  def delete; end
  def description; end
  def description_html; end
  def get; end
  def head; end
  def options; end
  def parameters; end
  def patch; end
  def post; end
  def put; end
  def servers; end
  def summary; end
  def trace; end
end
class Openapi3Parser::Node::Paths < Openapi3Parser::Node::Map
end
class Openapi3Parser::Node::Placeholder
  def field; end
  def initialize(node_factory, field, parent_context); end
  def nil_input?(*args, &block); end
  def node; end
  def node_factory; end
  def parent_context; end
  def self.each(node_data, &block); end
  def self.resolve(potential_placeholder); end
  extend Forwardable
end
class Openapi3Parser::Node::RequestBody < Openapi3Parser::Node::Object
  def content; end
  def description; end
  def description_html; end
  def required?; end
end
class Openapi3Parser::Node::Response < Openapi3Parser::Node::Object
  def content; end
  def description; end
  def description_html; end
  def headers; end
  def links; end
end
class Openapi3Parser::Node::Responses < Openapi3Parser::Node::Map
  def default; end
end
class Openapi3Parser::Node::Schema < Openapi3Parser::Node::Object
  def additional_properties?; end
  def additional_properties_schema; end
  def all_of; end
  def any_of; end
  def default; end
  def deprecated?; end
  def description; end
  def description_html; end
  def discriminator; end
  def enum; end
  def example; end
  def exclusive_maximum?; end
  def exclusive_minimum?; end
  def external_docs; end
  def format; end
  def items; end
  def max_items; end
  def max_length; end
  def max_properties; end
  def maximum; end
  def min_items; end
  def min_length; end
  def min_properties; end
  def minimum; end
  def multiple_of; end
  def name; end
  def not; end
  def nullable?; end
  def one_of; end
  def pattern; end
  def properties; end
  def read_only?; end
  def required; end
  def requires?(property); end
  def title; end
  def type; end
  def unique_items?; end
  def write_only?; end
  def xml; end
end
class Openapi3Parser::Node::SecurityRequirement < Openapi3Parser::Node::Map
end
class Openapi3Parser::Node::SecurityScheme < Openapi3Parser::Node::Object
  def bearer_format; end
  def description; end
  def description_html; end
  def flows; end
  def in; end
  def name; end
  def open_id_connect_url; end
  def scheme; end
  def type; end
end
class Openapi3Parser::Node::Server < Openapi3Parser::Node::Object
  def description; end
  def description_html; end
  def url; end
  def variables; end
end
class Openapi3Parser::Node::ServerVariable < Openapi3Parser::Node::Object
  def default; end
  def description; end
  def description_html; end
  def enum; end
end
class Openapi3Parser::Node::Tag < Openapi3Parser::Node::Object
  def description; end
  def description_html; end
  def external_docs; end
  def name; end
end
class Openapi3Parser::Node::Xml < Openapi3Parser::Node::Object
  def attribute?; end
  def name; end
  def namespace; end
  def prefix; end
  def wrapped?; end
end
module Openapi3Parser::NodeFactory
end
class Openapi3Parser::NodeFactory::Array
  def build_data(raw_input); end
  def build_node(data, node_context); end
  def build_resolved_input; end
  def context; end
  def data; end
  def default; end
  def errors; end
  def initialize(context, default: nil, use_default_on_empty: nil, value_input_type: nil, value_factory: nil, validate: nil); end
  def initialize_value_factory(field_context); end
  def inspect; end
  def nil_input?; end
  def node(node_context); end
  def process_data(data); end
  def raw_input; end
  def resolved_input; end
  def use_default?; end
  def use_default_on_empty; end
  def valid?; end
  def validation; end
  def value_factory; end
  def value_input_type; end
end
class Openapi3Parser::NodeFactory::Array::ValidNodeBuilder
  def build_node_data(parent_context); end
  def check_field_type(context, raise_on_invalid); end
  def check_values(raise_on_invalid: nil); end
  def collate_errors; end
  def data(parent_context); end
  def errors; end
  def factory; end
  def initialize(factory); end
  def run_validation; end
  def self.data(factory, parent_context); end
  def self.errors(factory); end
  def self.new(*arg0); end
  def validatable; end
  def validate(raise_on_invalid: nil); end
end
class Openapi3Parser::NodeFactory::Map
  def allow_extensions; end
  def build_data(raw_input); end
  def build_node(data, node_context); end
  def build_resolved_input; end
  def context; end
  def data; end
  def default; end
  def errors; end
  def initialize(context, allow_extensions: nil, default: nil, value_input_type: nil, value_factory: nil, validate: nil); end
  def initialize_value_factory(field_context); end
  def inspect; end
  def nil_input?; end
  def node(node_context); end
  def process_data(data); end
  def raw_input; end
  def resolved_input; end
  def valid?; end
  def validation; end
  def value_factory; end
  def value_input_type; end
end
class Openapi3Parser::NodeFactory::Map::ValidNodeBuilder
  def check_field_type(context, raise_on_invalid); end
  def check_keys(raise_on_invalid: nil); end
  def check_values(raise_on_invalid: nil); end
  def collate_errors; end
  def data(parent_context); end
  def default_value; end
  def errors; end
  def factory; end
  def initialize(factory); end
  def run_validation; end
  def self.data(factory, parent_context); end
  def self.errors(factory); end
  def self.new(*arg0); end
  def validatable; end
  def validate(raise_on_invalid: nil); end
end
class Openapi3Parser::NodeFactory::Callback < Openapi3Parser::NodeFactory::Map
  def build_node(data, node_context); end
  def initialize(context); end
end
module Openapi3Parser::NodeFactory::ObjectFactory
end
class Openapi3Parser::NodeFactory::ObjectFactory::FieldConfig
  def check_input_type(validatable, building_node: nil); end
  def default(factory = nil); end
  def factory?; end
  def given_default; end
  def given_factory; end
  def given_input_type; end
  def given_required; end
  def given_validate; end
  def initialize(input_type: nil, factory: nil, required: nil, default: nil, validate: nil); end
  def initialize_factory(context, parent_factory = nil); end
  def required?; end
  def run_validation(validatable); end
  def validate_field(validatable, building_node: nil); end
end
module Openapi3Parser::NodeFactory::ObjectFactory::Dsl
  def allow_extensions; end
  def allowed_extensions?; end
  def field(name, **options); end
  def field_configs; end
  def mutually_exclusive(*fields, required: nil); end
  def mutually_exclusive_fields; end
  def validate(*items, &block); end
  def validations; end
end
class Openapi3Parser::NodeFactory::ObjectFactory::Dsl::MutuallyExclusiveField < Struct
  def fields; end
  def fields=(_); end
  def required; end
  def required=(_); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
end
class Openapi3Parser::NodeFactory::Object
  def allowed_default?(*args, &block); end
  def allowed_extensions?(*args, &block); end
  def allowed_fields; end
  def build_data(raw_input); end
  def build_node(node_context); end
  def build_resolved_input; end
  def can_use_default?; end
  def context; end
  def data; end
  def default; end
  def errors; end
  def field_configs(*args, &block); end
  def initialize(context); end
  def inspect; end
  def mutually_exclusive_fields(*args, &block); end
  def nil_input?; end
  def node(node_context); end
  def process_data(raw_data); end
  def raw_input; end
  def required_fields; end
  def resolved_input; end
  def self.object_type; end
  def valid?; end
  def validations(*args, &block); end
  extend Forwardable
  extend Openapi3Parser::NodeFactory::ObjectFactory::Dsl
end
class Openapi3Parser::NodeFactory::Components < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def callbacks_factory(context); end
  def default; end
  def examples_factory(context); end
  def headers_factory(context); end
  def links_factory(context); end
  def parameters_factory(context); end
  def referenceable_map_factory(context, factory); end
  def request_bodies_factory(context); end
  def responses_factory(context); end
  def schemas_factory(context); end
  def security_schemes_factory(context); end
end
module Openapi3Parser::Validation
end
class Openapi3Parser::Validation::InputValidator
  def call(validatable); end
  def callable; end
  def initialize(callable); end
end
module Openapi3Parser::Validators
end
class Openapi3Parser::Validators::Email
  def self.call(input); end
end
class Openapi3Parser::Validators::Url
  def self.call(input); end
end
class Openapi3Parser::NodeFactory::Contact < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
end
class Openapi3Parser::NodeFactory::Context
  def ==(other); end
  def initialize(input, source_location:, reference_locations: nil); end
  def input; end
  def inspect; end
  def location_summary; end
  def reference_locations; end
  def resolve_reference(reference, factory, recursive: nil); end
  def self.next_field(parent_context, field, given_input = nil); end
  def self.resolved_reference(reference_context, source_location:); end
  def self.root(input, source); end
  def self_referencing?; end
  def source; end
  def source_location; end
  def to_s; end
end
class Openapi3Parser::NodeFactory::Context::UNDEFINED
end
class Openapi3Parser::NodeFactory::Discriminator < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def validate_mapping(validatable); end
end
class Openapi3Parser::NodeFactory::Encoding < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def default_explode; end
  def headers_factory(context); end
end
class Openapi3Parser::NodeFactory::Example < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
end
class Openapi3Parser::NodeFactory::ExternalDocumentation < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
end
class Openapi3Parser::NodeFactory::Field
  def build_node(data, _node_context); end
  def context; end
  def data; end
  def default; end
  def errors; end
  def initialize(context, input_type: nil, validate: nil); end
  def input_type; end
  def inspect; end
  def nil_input?; end
  def node(node_context); end
  def raw_input; end
  def resolved_input; end
  def valid?; end
  def validation; end
end
class Openapi3Parser::NodeFactory::Field::ValidNodeBuilder
  def data; end
  def default_value; end
  def errors; end
  def factory; end
  def initialize(factory); end
  def run_validation; end
  def self.data(factory); end
  def self.errors(factory); end
  def self.new(*arg0); end
  def validatable; end
  def validate(raise_on_invalid: nil); end
end
module Openapi3Parser::NodeFactory::Fields
end
class Openapi3Parser::NodeFactory::Fields::Reference < Openapi3Parser::NodeFactory::Field
  def build_node(_data, node_context); end
  def create_resolved_reference; end
  def factory; end
  def initialize(context, factory); end
  def reference; end
  def reference_resolves?; end
  def reference_validator; end
  def referenced_factory; end
  def resolved_input; end
  def resolved_reference; end
  def self_referencing?(*args, &block); end
  def validate(validatable); end
  extend Forwardable
end
class Openapi3Parser::NodeFactory::Fields::Reference::RecursiveResolvedInput
  def [](*args, &block); end
  def each(*args, &block); end
  def factory; end
  def initialize(factory); end
  def keys(*args, &block); end
  def value; end
  extend Forwardable
  include Enumerable
end
module Openapi3Parser::NodeFactory::ParameterLike
  def content_factory(context); end
  def default_explode; end
  def examples_factory(context); end
  def schema_factory(context); end
  def validate_content(validatable); end
end
class Openapi3Parser::NodeFactory::Header < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  include Openapi3Parser::NodeFactory::ParameterLike
end
class Openapi3Parser::NodeFactory::License < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
end
class Openapi3Parser::NodeFactory::Info < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
end
class Openapi3Parser::NodeFactory::Link < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def parameters_factory(context); end
  def server_factory(context); end
end
class Openapi3Parser::NodeFactory::MediaType < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def encoding_factory(context); end
  def examples_factory(context); end
  def schema_factory(context); end
end
class Openapi3Parser::NodeFactory::MediaType::EncodingValidator
  def call(validatable); end
  def error_message(missing_keys); end
  def factory; end
  def initialize(factory); end
  def properties; end
end
class Openapi3Parser::NodeFactory::OauthFlow < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
end
class Openapi3Parser::NodeFactory::OauthFlows < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def oauth_flow_factory(context); end
end
class Openapi3Parser::NodeFactory::ObjectFactory::NodeBuilder
  def build_node_data(node_context); end
  def determine_value_or_default(key, value); end
  def empty_and_allowed_to_be?; end
  def errors; end
  def factory; end
  def initialize(factory); end
  def node_data(node_context); end
  def resolve_value(key, value, node_context); end
  def self.errors(factory); end
  def self.new(*arg0); end
  def self.node_data(factory, node_context); end
  def validatable; end
  def validate(raise_on_invalid:); end
end
class Openapi3Parser::NodeFactory::ObjectFactory::Validator
  def call; end
  def check_factory_validations; end
  def check_invalid_fields; end
  def check_mutually_exclusive_fields; end
  def check_required_fields; end
  def check_unexpected_fields; end
  def factory; end
  def initialize(factory, raise_on_invalid: nil); end
  def raise_on_invalid; end
  def self.call(*args, **kwargs); end
  def self.new(*arg0); end
  def validatable; end
end
class Openapi3Parser::NodeFactory::ObjectFactory::Validator::CheckInvalidFields
  def call; end
  def check_field(name, field_config); end
  def factory(*args, &block); end
  def handle_factory_checks(name); end
  def in_recursive_loop?(field); end
  def initialize(validator); end
  def raise_on_invalid(*args, &block); end
  def self.call(validator); end
  def self.new(*arg0); end
  def validatable(*args, &block); end
  def validator; end
  extend Forwardable
end
class Openapi3Parser::NodeFactory::ObjectFactory::Validator::CheckFactoryValidations
  def call(validator); end
  def run_validations(validator); end
  def self.call(validator); end
  def self.new(*arg0); end
end
class Openapi3Parser::NodeFactory::Paths < Openapi3Parser::NodeFactory::Map
  def build_node(data, node_context); end
  def conflicting_paths(paths); end
  def initialize(context); end
  def validate(validatable); end
  def validate_paths(validatable, paths); end
end
class Openapi3Parser::NodeFactory::Openapi < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def can_use_default?; end
  def security_factory(context); end
  def servers_factory(context); end
  def tags_factory(context); end
end
class Openapi3Parser::NodeFactory::Responses < Openapi3Parser::NodeFactory::Map
  def build_node(data, node_context); end
  def initialize(context); end
  def validate_keys(validatable); end
end
class Openapi3Parser::NodeFactory::Operation < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def callbacks_factory(context); end
  def parameters_factory(context); end
  def path_item_server_data(node_context); end
  def request_body_factory(context); end
  def responses_factory(context); end
  def security_factory(context); end
  def servers_factory(context); end
  def tags_factory(context); end
end
class Openapi3Parser::NodeFactory::OptionalReference
  def call(context); end
  def factory; end
  def initialize(factory); end
  def object_type; end
end
class Openapi3Parser::NodeFactory::Parameter < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def default_style; end
  def validate_in(validatable); end
  include Openapi3Parser::NodeFactory::ParameterLike
end
class Openapi3Parser::NodeFactory::PathItem < Openapi3Parser::NodeFactory::Object
  def build_object(data, node_context); end
  def build_resolved_input; end
  def merge_data(base, priority); end
  def operation_factory(context); end
  def parameters_factory(context); end
  def ref_factory(context); end
  def root_server_data(node_context); end
  def servers_factory(context); end
end
class Openapi3Parser::NodeFactory::Reference < Openapi3Parser::NodeFactory::Object
  def build_node(node_context); end
  def build_resolved_input; end
  def errors; end
  def factory; end
  def in_recursive_loop?; end
  def initialize(context, factory); end
  def ref_factory(context); end
  def referenced_factory; end
  def resolves?(control_factory = nil); end
end
class Openapi3Parser::NodeFactory::RequestBody < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def content_factory(context); end
end
class Openapi3Parser::NodeFactory::RequestBody::ContentValidator
  def call(validatable); end
  def self.call(*args); end
end
class Openapi3Parser::NodeFactory::Response < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def content_factory(context); end
  def headers_factory(context); end
  def links_factory(context); end
  def validate_content(validatable); end
end
class Openapi3Parser::NodeFactory::Schema < Openapi3Parser::NodeFactory::Object
  def additional_properties_factory(context); end
  def additional_properties_input_type(validatable); end
  def build_object(data, context); end
  def discriminator_factory(context); end
  def enum_factory(context); end
  def external_docs_factory(context); end
  def items_for_array(validatable); end
  def properties_factory(context); end
  def read_only_or_write_only(validatable); end
  def referenceable_schema(context); end
  def referenceable_schema_array(context); end
  def required_factory(context); end
  def xml_factory(context); end
end
class Openapi3Parser::NodeFactory::SecurityRequirement < Openapi3Parser::NodeFactory::Map
  def build_node(data, node_context); end
  def initialize(context); end
end
class Openapi3Parser::NodeFactory::SecurityScheme < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def flows_factory(context); end
end
class Openapi3Parser::NodeFactory::Server < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def variables_factory(context); end
end
class Openapi3Parser::NodeFactory::ServerVariable < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
  def enum_factory(context); end
end
class Openapi3Parser::NodeFactory::Tag < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
end
class Openapi3Parser::NodeFactory::TypeChecker
  def field_error_message; end
  def initialize(type); end
  def keys_error_message; end
  def raise_on_invalid_keys(context); end
  def raise_on_invalid_type(context); end
  def self.new(*arg0); end
  def self.raise_on_invalid_keys(context, type:); end
  def self.raise_on_invalid_type(context, type:); end
  def self.validate_keys(validatable, type:, context: nil); end
  def self.validate_type(validatable, type:, context: nil); end
  def type; end
  def type_name_for_error; end
  def valid_keys?(input); end
  def valid_type?(input); end
  def validate_keys(validatable, context); end
  def validate_type(validatable, context); end
end
class Openapi3Parser::Validators::AbsoluteUri
  def self.call(input); end
end
class Openapi3Parser::NodeFactory::Xml < Openapi3Parser::NodeFactory::Object
  def build_object(data, context); end
end
class Openapi3Parser::Source
  def ==(other); end
  def available?; end
  def data; end
  def data_at_pointer(json_pointer); end
  def document; end
  def has_pointer?(json_pointer); end
  def initialize(source_input, document, reference_registry, parent = nil); end
  def inspect; end
  def normalize_data(input); end
  def parent; end
  def reference_registry; end
  def relative_to_root; end
  def resolve_reference(given_reference, unbuilt_factory, context, recursive: nil); end
  def resolve_source(reference); end
  def root?; end
  def source_input; end
end
class Openapi3Parser::Source::Location
  def ==(other); end
  def data; end
  def initialize(source, pointer_segments); end
  def inspect; end
  def pointer; end
  def pointer_defined?; end
  def root?(*args, &block); end
  def self.next_field(location, field); end
  def source; end
  def source_available?; end
  def to_s; end
  extend Forwardable
end
class Openapi3Parser::Source::Pointer
  def ==(other); end
  def absolute; end
  def fragment; end
  def initialize(segments, absolute: nil); end
  def inspect; end
  def root?; end
  def segments; end
  def self.from_fragment(fragment); end
  def self.merge_pointers(base_pointer, new_pointer); end
  def to_s; end
end
class Openapi3Parser::Source::Pointer::MergePointers
  def base_pointer; end
  def call; end
  def create_pointer(pointer_like); end
  def initialize(base_pointer, new_pointer); end
  def merge_pointers(pointer_a, pointer_b); end
  def new_pointer; end
  def self.call(*args); end
  def self.new(*arg0); end
end
class Openapi3Parser::Source::Reference
  def absolute?; end
  def fragment; end
  def given_reference; end
  def initialize(reference); end
  def json_pointer; end
  def only_fragment?; end
  def resource_uri; end
  def to_s; end
  def uri; end
  def uri_without_fragment; end
end
class Openapi3Parser::Source::ResolvedReference
  def build_errors; end
  def errors; end
  def factory; end
  def initialize(source_location:, object_type:, reference_registry:); end
  def node(*args, &block); end
  def object_type; end
  def pointer_missing_error; end
  def reference_registry; end
  def resolution_error; end
  def resolved_input(*args, &block); end
  def source(*args, &block); end
  def source_location; end
  def source_unavailabe_error; end
  def valid?; end
  extend Forwardable
end
class Openapi3Parser::SourceInput
  def ==(_other); end
  def access_error; end
  def available?; end
  def contents; end
  def initialize; end
  def parse_error; end
  def relative_to(_source_input); end
  def resolve_next(_reference); end
end
class Openapi3Parser::SourceInput::File < Openapi3Parser::SourceInput
  def ==(other); end
  def initialize(path, working_directory: nil); end
  def inspect; end
  def parse_contents; end
  def path; end
  def relative_path(from, to); end
  def relative_to(source_input); end
  def resolve_next(reference); end
  def resolve_working_directory; end
  def to_s; end
  def working_directory; end
end
class Openapi3Parser::SourceInput::Raw < Openapi3Parser::SourceInput
  def ==(other); end
  def base_url; end
  def initialize(raw_input, base_url: nil, working_directory: nil); end
  def input_to_string(input); end
  def inspect; end
  def parse_contents; end
  def raw_input; end
  def resolve_next(reference); end
  def resolve_working_directory; end
  def to_s; end
  def working_directory; end
end
class Openapi3Parser::SourceInput::ResolveNext
  def base_url; end
  def current_source_input; end
  def file_source_input; end
  def initialize(reference, current_source_input, base_url, working_directory); end
  def reference; end
  def self.call(reference, current_source_input, base_url: nil, working_directory: nil); end
  def self.new(*arg0); end
  def source_input; end
  def url_source_input; end
  def working_directory; end
end
class Openapi3Parser::SourceInput::StringParser
  def call; end
  def filename; end
  def initialize(input, filename); end
  def input; end
  def json?; end
  def parse_json; end
  def parse_yaml; end
  def self.call(input, filename = nil); end
  def self.new(*arg0); end
end
class Openapi3Parser::SourceInput::Url < Openapi3Parser::SourceInput
  def ==(other); end
  def initialize(request_url); end
  def inspect; end
  def parse_contents; end
  def relative_to(source_input); end
  def request_url; end
  def resolve_next(reference); end
  def resolved_url; end
  def to_s; end
  def url; end
end
class Openapi3Parser::SourceInput::Url::RelativeUrlDifference
  def call; end
  def different_hosts?; end
  def file_and_query(uri); end
  def from_uri; end
  def initialize(from_url, to_url); end
  def relative_path; end
  def self.call(from_url, to_url); end
  def self.new(*arg0); end
  def to_uri; end
end
class Openapi3Parser::Validation::Error
  def ==(other); end
  def context; end
  def factory_class; end
  def for_type; end
  def initialize(message, context, factory_class = nil); end
  def inspect; end
  def message; end
  def source_location(*args, &block); end
  def to_s; end
  extend Forwardable
end
class Openapi3Parser::Validation::ErrorCollection
  def each(&block); end
  def empty?; end
  def errors; end
  def group_errors; end
  def initialize(errors = nil); end
  def inspect; end
  def self.combine(errors, other_errors); end
  def to_a; end
  def to_h; end
  include Enumerable
end
class Openapi3Parser::Validation::ErrorCollection::LocationTypeGroup < Struct
  def errors; end
  def errors=(_); end
  def for_type; end
  def for_type=(_); end
  def location_summary(with_type: nil); end
  def self.[](*arg0); end
  def self.inspect; end
  def self.members; end
  def self.new(*arg0); end
  def source_location; end
  def source_location=(_); end
end
class Openapi3Parser::Validation::Validatable
  def add_error(error, given_context = nil, factory_class = nil); end
  def add_errors(errors); end
  def collection; end
  def context; end
  def errors; end
  def factory; end
  def initialize(factory, context: nil); end
  def input; end
end
class Openapi3Parser::Validation::Validatable::UNDEFINED
end
class Openapi3Parser::Validators::ComponentKeys
  def self.call(input); end
end
class Openapi3Parser::Validators::DuplicateParameters
  def call(resolved_input); end
  def duplicate_names_by_in(resolved_input); end
  def message(dupes); end
  def self.call(resolved_input); end
end
class Openapi3Parser::Validators::MediaType
  def self.call(input); end
end
class Openapi3Parser::Validators::MutuallyExclusiveFields
  def call(validatable, mutually_exclusive_fields:, raise_on_invalid: nil); end
  def handle_exclusive_errors(validatable, exclusive_errors, raise_on_invalid); end
  def handle_required_errors(validatable, required_errors, raise_on_invalid); end
  def self.call(*args, **kwargs); end
  def self.new(*arg0); end
end
class Openapi3Parser::Validators::MutuallyExclusiveFields::MutuallyExclusiveFieldErrors
  def add_error(errors, mutually_exclusive); end
  def count_non_nil_fields(fields); end
  def errors; end
  def exclusive_error(fields); end
  def exclusive_errors; end
  def initialize(mutually_exclusive_fields, input); end
  def input; end
  def mutually_exclusive_fields; end
  def required_error(fields); end
  def required_errors; end
end
class Openapi3Parser::Validators::Reference
  def build_errors; end
  def check_fragment(uri); end
  def errors; end
  def given_reference; end
  def initialize(given_reference); end
  def valid?; end
end
class Openapi3Parser::Validators::RequiredFields
  def call(validatable, required_fields:, raise_on_invalid: nil); end
  def self.call(*args, **kwargs); end
  def self.new(*arg0); end
end
class Openapi3Parser::Validators::UnexpectedFields
  def call(validatable, allowed_fields:, allow_extensions: nil, raise_on_invalid: nil); end
  def self.call(*args, **kwargs); end
  def self.new(*arg0); end
  def unexpected_fields(input, allowed_fields, allow_extensions); end
end
